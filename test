# 2.3 명령어 파이프라이닝
cpu의 프로그램 처리 속도를 높이기 위해, CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술

## 2단계 명령어 파이프라인 (two-stage instruction pipeline)
- 명령어 실행 하드웨어를 인출 단계 + 실행 단계라는 두 개의 독립적인 파이프라인 모듈로 분리.(fetch stage + execute stage)
- **두 단계의 처리 시간이 동일하면** 2배의 속도 향상을 가짐.
- 만약에 그게 어렵다면 **파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함**
- 단계 수를 늘리면 전체적으로 속도 향상이 더 높아진다.

So,
## 4-단계 명령어 파이프라인 도입
**IF -> ID -> OF -> EX**
1. 명령어 인출 - IF: 다음 명령어를 기억장치로 부터 인출
2. 명령어 해독 - ID: 해독기(decoder)를 이용하여 명령어 해석
3. 오퍼랜드 인출 - OF: 기억장치로 부터 오퍼랜드 인출
4. 실행 - EX: 지정된 연산 수행
**명령어 인출 -> 명령어 해독 -> 오퍼랜드 인출 -> 연산 실행**


## ⭐ 전체 명령어 실행 시간 계산! ⭐
- 파이프라인 단계 수: k
- 실행할 명령어 수: N
- 각 파이프라인 단계가 한 클럭 주기씩 걸린다고 가정하면,

### ⭐ T = k (N - 1) ⭐
첫 번째 명령어를 실행하는데 k만큼 걸리고 나머지 N-1개의 명령어는 한 주기씨만 소요된다!
- 파이프라인 X인 경우 **T = k x N**
- 이걸로 효율을 구할 수 있겠지??

### 파이프라인에 의한 속도 향상 - speedup
![화면 캡처 2022-06-02 141837](https://user-images.githubusercontent.com/71186266/171558071-c62690b5-1eb2-447a-826c-4755cdec94f0.png)
극한으로 보내면 **이론상 최대 k배의 속도 향상이 가능합니다.**
**효율 S = T1 / Tk = k x N / k + (N-1)**


## 효율 저하의 원인들
1. 모든 명령어들이 파이프라인 단계를 전부 거치진 않음.
- 그래도 억지로 불필요한 단계를 거치게 만들어 줘서 맞춰야함.
2. 파이프라인 클록은 **처리 시간이 가장 오래 걸리는 단계를 기준으로 결정됨** 
3. 명령어 인출과 오퍼랜드 인출(IF, OF)이 동시에 기억장치를 액세스 하는 경우, 기억장치 충돌이 일어나면 지연 발생
4. 조건 분기 명령어가 실행되면, 미리 인출하여 처리하던 명령어들이 무효화됨.

## 분기 발생에 의한 성능 저하를 최소화 시키는 방법
1. *8분기 예측(branch prediction)*8
- 분기가 일어날 것인지 예측하고, 그에 따라 명령어를 인출하는 확률적인 방법. 절대적인 방법이 아님. 
2. **분기 목적지 선인출(prefetch) - true false 전부 가져와.**
- 분기 명령어의 다음 명령어 뿐만 아니라 분기의 목적지 명령어도 함께 인출하여 실행하는 방법!
3. **loop buffer 사용**: 파이프라인 인출 단꼐에 포함된 작은 고속기억장치 루프 버퍼에 가장 최근 인출된 n개의 명령어들을 순서대로 저장함
4. **지연 분기(delayed branch)**: 분기 명령어의 위치를 재패치해서 성능 개선, 큰 영향 없어? 뒤로 꺼져!


# Super Scalar!
- CPU 속도를 더욲! 높이기 위해 내부에 2개 이상의 명령어 파이프라인들을 포함시킨 구조!
- 파이프라인의 수에 따라 M-way 슈퍼스칼라 라고 불리웁니다.
- 파이프라인을 **다중 경로**로 만든 것. 각 명령어 파이프라인이 별도의 명령어를 인출하여 동시에 실행합니다. **이론적으로 프로그램 처리 속도가 파이프라인 수 만큼 향상**

## super scalar speedup!
1. 단일 파이프라인 실행시간 (명령어 수 N)
- T(1) = k + N - 1
2. m-way 슈퍼스칼라에 의한 실행 시간
- 첫 명령어 set의 명령어 m개는 어쩔 수 없이 k의 시간이 걸립니다. 이후, N - m개의 명령어는 m개씩 불러왔으므로, 파이프라인 1개씩 뒤에 붙는 것이 (N-m)/m 개가 붙습니다 그래서 나온 식이..
 ![화면 캡처 2022-06-02 162709](https://user-images.githubusercontent.com/71186266/171576835-54b659ef-353a-467c-a42d-236b09c17ce0.png)

3. **최종 속도향상!** 두 식을 이용한 효율입니다.
![화면 캡처 2022-06-02 163614](https://user-images.githubusercontent.com/71186266/171578517-1dc23ec5-6911-4feb-a014-bdb3b5877635.png)
**명령어 수가 충분히 많을 때(극한) 이론상 m배의 속도 향상이 있습니다!**

## P. 슈퍼스칼라 속도 저하 요인
- 명령어들 간의 데이터 의존 관계: A의 결과가 B에 쓰이는 경우
- 하트웨어 이용 경합 발생.. 무수한 이용의 요청이..
-> 동시 실행 가능 명령어 수가 < m이 되버린다

## S. 어떻게 해결?
- 명령어 실행 순서 재배치로, 데이터 의존성 제거 -> 말이 되냐?
- 하드웨어 추가(중복)설치로 경합 감소 -> 더 말이 안 된다 ㅋㅋ

# S! 듀얼-코어, 멀티 코어
- CPU코어: 명령어 실행에 필요한 CPU 내부의 핵심 하드웨어 모듈 (슈퍼스칼라 H/W, ALU, 레지스터 등..)
- 멀티-코어 프로세서: 여러개의 CPU 코어들을 하나의 칩에 포함시킨 프로세서! 듀얼, 쿼드, 헥사 코어 등등 있음
- 칩-레벨 다중프로세서 or 단일-칩 다중프로세서 라고도 부름.

## 듀얼-코어 프로세서
- 단일 코어에 비해 2배의 속도 향상 기대
- 코어들은 **내부 캐시와 시스템 버스 인터페이스만 공유**
- **코어 별로 독립적 프로그램 실행 - 멀티 태스킹과 멀티 스레딩 지원** 
